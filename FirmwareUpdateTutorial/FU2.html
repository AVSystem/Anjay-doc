

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.2. Basic implementation &mdash; Anjay 2.6.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.3. Download modes and protocols" href="FU3.html" />
    <link rel="prev" title="6.1. Firmware Update" href="FU1.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Anjay
          

          
          </a>

          
            
            
              <div class="version">
                2.6.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LwM2M.html">2. OMA LwM2M - Brief description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Compiling_client_applications.html">3. Compiling client applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../BasicClient.html">4. Basic client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdvancedTopics.html">5. Advanced topics</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../FirmwareUpdateTutorial.html">6. Firmware Update Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="FU1.html">6.1. Firmware Update</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.2. Basic implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU3.html">6.3. Download modes and protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU4.html">6.4. Secure downloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU5.html">6.5. Poor network connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU6.html">6.6. Download resumption</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Tools.html">7. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PortingGuideForNonPOSIXPlatforms.html">8. Porting guide for non-POSIX platforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Migrating.html">9. Migrating from older versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Commercial_support.html">10. Commercial support</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Anjay</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../FirmwareUpdateTutorial.html">6. Firmware Update Tutorial</a> &raquo;</li>
        
      <li>6.2. Basic implementation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/FirmwareUpdateTutorial/FU2.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="basic-implementation">
<h1>6.2. Basic implementation<a class="headerlink" href="#basic-implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="project-structure">
<h2>6.2.1. Project structure<a class="headerlink" href="#project-structure" title="Permalink to this headline">¶</a></h2>
<p>We shall start with the code from <a class="reference internal" href="../BasicClient/BC6.html"><span class="doc">Notifications support</span></a> chapter. In the
end, our project structure would look as follows:</p>
<div class="code highlight-default notranslate"><div class="highlight"><pre><span></span>examples/tutorial/firmware-update/basic-implementation/
├── CMakeLists.txt
└── src
    ├── firmware_update.c
    ├── firmware_update.h
    ├── main.c
    ├── time_object.c
    └── time_object.h
</pre></div>
</div>
<p>Note the <code class="docutils literal notranslate"><span class="pre">firmware_update.c</span></code> and <code class="docutils literal notranslate"><span class="pre">firmware_update.h</span></code> are introduced in this
chapter.</p>
</div>
<div class="section" id="installing-the-firmware-update-module">
<h2>6.2.2. Installing the Firmware Update module<a class="headerlink" href="#installing-the-firmware-update-module" title="Permalink to this headline">¶</a></h2>
<p>In order to install the module, we are going to use:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">anjay_fw_update_install</span><span class="p">(</span>
        <span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">anjay_fw_update_handlers_t</span> <span class="o">*</span><span class="n">handlers</span><span class="p">,</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">user_arg</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">anjay_fw_update_initial_state_t</span> <span class="o">*</span><span class="n">initial_state</span><span class="p">);</span>
</pre></div>
</div>
<p>The important arguments for us at this point are <code class="docutils literal notranslate"><span class="pre">anjay</span></code>, <code class="docutils literal notranslate"><span class="pre">handlers</span></code>
and <code class="docutils literal notranslate"><span class="pre">user_arg</span></code>.</p>
<p>We already discussed <code class="docutils literal notranslate"><span class="pre">handlers</span></code> structure in <a class="reference internal" href="FU1.html#firmware-update-api"><span class="std std-ref">API in Anjay</span></a>, and we will
shortly provide simple implementations of required callbacks.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">user_arg</span></code> <strong>is a pointer passed to every callback, when Anjay
actually calls it</strong>. This pointer can be used by the callback implementation
to store any kind of context to operate on. Alternatively, the implementation
may set it to <cite>NULL</cite> and rely on the use of global variables.</p>
</div>
<p>In our code, firmware update module installation will be taken care of by
the function declared in <code class="docutils literal notranslate"><span class="pre">firmware_update.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef FIRMWARE_UPDATE_H</span>
<span class="cp">#define FIRMWARE_UPDATE_H</span>
<span class="cp">#include</span> <span class="cpf">&lt;anjay/anjay.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;anjay/fw_update.h&gt;</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * Buffer for the endpoint name that will be used when re-launching the client</span>
<span class="cm"> * after firmware upgrade.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ENDPOINT_NAME</span><span class="p">;</span>

<span class="hll"><span class="cm">/**</span>
</span><span class="hll"><span class="cm"> * Installs the firmware update module.</span>
</span><span class="hll"><span class="cm"> *</span>
</span><span class="hll"><span class="cm"> * @returns 0 on success, negative value otherwise.</span>
</span><span class="hll"><span class="cm"> */</span>
</span><span class="hll"><span class="kt">int</span> <span class="nf">fw_update_install</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">);</span>
</span>
<span class="cp">#endif </span><span class="c1">// FIRMWARE_UPDATE_H</span>
</pre></div>
</div>
<p>We invoke it in <code class="docutils literal notranslate"><span class="pre">main.c</span></code> by performing two (highlighted) modifications:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;anjay/anjay.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;anjay/attr_storage.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;anjay/security.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;anjay/server.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;avsystem/commons/avs_log.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;poll.h&gt;</span><span class="cp"></span>

<span class="hll"><span class="cp">#include</span> <span class="cpf">&quot;firmware_update.h&quot;</span><span class="cp"></span>
</span><span class="cp">#include</span> <span class="cpf">&quot;time_object.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main_loop</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">,</span> <span class="k">const</span> <span class="n">anjay_dm_object_def_t</span> <span class="o">**</span><span class="n">time_object</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Obtain all network data sources</span>
        <span class="n">AVS_LIST</span><span class="p">(</span><span class="n">avs_net_socket_t</span> <span class="o">*</span><span class="k">const</span><span class="p">)</span> <span class="n">sockets</span> <span class="o">=</span> <span class="n">anjay_get_sockets</span><span class="p">(</span><span class="n">anjay</span><span class="p">);</span>

        <span class="c1">// Prepare to poll() on them</span>
        <span class="kt">size_t</span> <span class="n">numsocks</span> <span class="o">=</span> <span class="n">AVS_LIST_SIZE</span><span class="p">(</span><span class="n">sockets</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">pollfds</span><span class="p">[</span><span class="n">numsocks</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">AVS_LIST</span><span class="p">(</span><span class="n">avs_net_socket_t</span> <span class="o">*</span><span class="k">const</span><span class="p">)</span> <span class="n">sock</span><span class="p">;</span>
        <span class="n">AVS_LIST_FOREACH</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sockets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">pollfds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">avs_net_socket_get_system</span><span class="p">(</span><span class="o">*</span><span class="n">sock</span><span class="p">);</span>
            <span class="n">pollfds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
            <span class="n">pollfds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">max_wait_time_ms</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
        <span class="c1">// Determine the expected time to the next job in milliseconds.</span>
        <span class="c1">// If there is no job we will wait till something arrives for</span>
        <span class="c1">// at most 1 second (i.e. max_wait_time_ms).</span>
        <span class="kt">int</span> <span class="n">wait_ms</span> <span class="o">=</span>
                <span class="n">anjay_sched_calculate_wait_time_ms</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="n">max_wait_time_ms</span><span class="p">);</span>

        <span class="c1">// Wait for the events if necessary, and handle them.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="n">pollfds</span><span class="p">,</span> <span class="n">numsocks</span><span class="p">,</span> <span class="n">wait_ms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">socket_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">AVS_LIST</span><span class="p">(</span><span class="n">avs_net_socket_t</span> <span class="o">*</span><span class="k">const</span><span class="p">)</span> <span class="n">socket</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">AVS_LIST_FOREACH</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">sockets</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pollfds</span><span class="p">[</span><span class="n">socket_id</span><span class="p">].</span><span class="n">revents</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_serve</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="o">*</span><span class="n">socket</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">avs_log</span><span class="p">(</span><span class="n">tutorial</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="s">&quot;anjay_serve failed&quot;</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="o">++</span><span class="n">socket_id</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Notify the library about a Resource value change</span>
        <span class="n">time_object_notify</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="n">time_object</span><span class="p">);</span>

        <span class="c1">// Finally run the scheduler</span>
        <span class="n">anjay_sched_run</span><span class="p">(</span><span class="n">anjay</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Installs Security Object and adds and instance of it.</span>
<span class="c1">// An instance of Security Object provides information needed to connect to</span>
<span class="c1">// LwM2M server.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_security_object</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_security_object_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">PSK_IDENTITY</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;identity&quot;</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">PSK_KEY</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;P4s$w0rd&quot;</span><span class="p">;</span>

    <span class="n">anjay_security_instance_t</span> <span class="n">security_instance</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">ssid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">server_uri</span> <span class="o">=</span> <span class="s">&quot;coaps://try-anjay.avsystem.com:5684&quot;</span><span class="p">,</span>
        <span class="p">.</span><span class="n">security_mode</span> <span class="o">=</span> <span class="n">ANJAY_SECURITY_PSK</span><span class="p">,</span>
        <span class="p">.</span><span class="n">public_cert_or_psk_identity</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">PSK_IDENTITY</span><span class="p">,</span>
        <span class="p">.</span><span class="n">public_cert_or_psk_identity_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">PSK_IDENTITY</span><span class="p">),</span>
        <span class="p">.</span><span class="n">private_cert_or_psk_key</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">PSK_KEY</span><span class="p">,</span>
        <span class="p">.</span><span class="n">private_cert_or_psk_key_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">PSK_KEY</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// Anjay will assign Instance ID automatically</span>
    <span class="n">anjay_iid_t</span> <span class="n">security_instance_id</span> <span class="o">=</span> <span class="n">ANJAY_ID_INVALID</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_security_object_add_instance</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">security_instance</span><span class="p">,</span>
                                           <span class="o">&amp;</span><span class="n">security_instance_id</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Installs Server Object and adds and instance of it.</span>
<span class="c1">// An instance of Server Object provides the data related to a LwM2M Server.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">setup_server_object</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_server_object_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">anjay_server_instance_t</span> <span class="n">server_instance</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1">// Server Short ID</span>
        <span class="p">.</span><span class="n">ssid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="c1">// Client will send Update message often than every 60 seconds</span>
        <span class="p">.</span><span class="n">lifetime</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
        <span class="c1">// Disable Default Minimum Period resource</span>
        <span class="p">.</span><span class="n">default_min_period</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1">// Disable Default Maximum Period resource</span>
        <span class="p">.</span><span class="n">default_max_period</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1">// Disable Disable Timeout resource</span>
        <span class="p">.</span><span class="n">disable_timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="c1">// Sets preferred transport to UDP</span>
        <span class="p">.</span><span class="n">binding</span> <span class="o">=</span> <span class="s">&quot;U&quot;</span>
    <span class="p">};</span>

    <span class="c1">// Anjay will assign Instance ID automatically</span>
    <span class="n">anjay_iid_t</span> <span class="n">server_instance_id</span> <span class="o">=</span> <span class="n">ANJAY_ID_INVALID</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_server_object_add_instance</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server_instance</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">server_instance_id</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">avs_log</span><span class="p">(</span><span class="n">tutorial</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="s">&quot;usage: %s ENDPOINT_NAME&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ENDPOINT_NAME</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

    <span class="k">const</span> <span class="n">anjay_configuration_t</span> <span class="n">CONFIG</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">endpoint_name</span> <span class="o">=</span> <span class="n">ENDPOINT_NAME</span><span class="p">,</span>
        <span class="p">.</span><span class="n">in_buffer_size</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
        <span class="p">.</span><span class="n">out_buffer_size</span> <span class="o">=</span> <span class="mi">4000</span><span class="p">,</span>
        <span class="p">.</span><span class="n">msg_cache_size</span> <span class="o">=</span> <span class="mi">4000</span>
    <span class="p">};</span>

    <span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span> <span class="o">=</span> <span class="n">anjay_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONFIG</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">anjay</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">avs_log</span><span class="p">(</span><span class="n">tutorial</span><span class="p">,</span> <span class="n">ERROR</span><span class="p">,</span> <span class="s">&quot;Could not create Anjay object&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Install Attribute storage and setup necessary objects</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anjay_attr_storage_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">)</span> <span class="o">||</span> <span class="n">setup_security_object</span><span class="p">(</span><span class="n">anjay</span><span class="p">)</span>
<span class="hll">            <span class="o">||</span> <span class="n">setup_server_object</span><span class="p">(</span><span class="n">anjay</span><span class="p">)</span> <span class="o">||</span> <span class="n">fw_update_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">))</span> <span class="p">{</span>
</span>        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">anjay_dm_object_def_t</span> <span class="o">**</span><span class="n">time_object</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">time_object</span> <span class="o">=</span> <span class="n">time_object_create</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">time_object</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">anjay_register_object</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="n">time_object</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">main_loop</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="n">time_object</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">anjay_delete</span><span class="p">(</span><span class="n">anjay</span><span class="p">);</span>
    <span class="n">time_object_release</span><span class="p">(</span><span class="n">time_object</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>As you may see, there is also an additional <code class="docutils literal notranslate"><span class="pre">ENDPOINT_NAME</span></code> global
variable that now stores the command line argument. As we will use the same
kind of program binary as the update image, we will need this to properly
launch it as part of the upgrade process.</p>
<p class="last">This is usually not necessary in production code, as the endpoint name is
usually either hard-coded, or configured through other means.</p>
</div>
</div>
<div class="section" id="implementing-handlers-and-installation-routine">
<h2>6.2.3. Implementing handlers and installation routine<a class="headerlink" href="#implementing-handlers-and-installation-routine" title="Permalink to this headline">¶</a></h2>
<p>First, let’s think about what would we need to implement I/O operations
required to download the firmware. The approach we could take is to
open a <code class="docutils literal notranslate"><span class="pre">FILE</span></code> during a call to the <code class="docutils literal notranslate"><span class="pre">stream_open</span></code> callback, write to
it in <code class="docutils literal notranslate"><span class="pre">stream_write</span></code>, and close it in <code class="docutils literal notranslate"><span class="pre">stream_finish</span></code>. The only detail
remaining is: how are we going to share <code class="docutils literal notranslate"><span class="pre">FILE</span> <span class="pre">*</span></code> pointer between all
of these?</p>
<p>We can use a globally allocated structure and pack entire shared state into
it. In <code class="docutils literal notranslate"><span class="pre">firmware_update.c</span></code> it looks like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;./firmware_update.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="hll"><span class="k">static</span> <span class="k">struct</span> <span class="n">fw_state_t</span> <span class="p">{</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">firmware_file</span><span class="p">;</span> <span class="p">}</span> <span class="n">FW_STATE</span><span class="p">;</span>
</span></pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The numerous headers included will be useful in further stages of the
development.</p>
</div>
<p id="fw-download-io">Having the global state structure, we can proceed with implementation of:
<code class="docutils literal notranslate"><span class="pre">fw_stream_open</span></code>, <code class="docutils literal notranslate"><span class="pre">fw_stream_write</span></code> and <code class="docutils literal notranslate"><span class="pre">fw_stream_finish</span></code>, keeping in mind
our brief discussion at the beginning of the section:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">fw_state_t</span> <span class="p">{</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">firmware_file</span><span class="p">;</span> <span class="p">}</span> <span class="n">FW_STATE</span><span class="p">;</span>

<span class="hll"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span> <span class="o">=</span> <span class="s">&quot;/tmp/firmware_image.bin&quot;</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_open</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span>
</span><span class="hll">                          <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">package_uri</span><span class="p">,</span>
</span><span class="hll">                          <span class="k">const</span> <span class="k">struct</span> <span class="n">anjay_etag</span> <span class="o">*</span><span class="n">package_etag</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="c1">// For a moment, we don&#39;t need to care about any of the arguments passed.</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">package_uri</span><span class="p">;</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">package_etag</span><span class="p">;</span>
</span><span class="hll">
</span><span class="hll">    <span class="c1">// It&#39;s worth ensuring we start with a NULL firmware_file. In the end</span>
</span><span class="hll">    <span class="c1">// it would be our responsibility to manage this pointer, and we want</span>
</span><span class="hll">    <span class="c1">// to make sure we never leak any memory.</span>
</span><span class="hll">    <span class="n">assert</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="hll">    <span class="c1">// We&#39;re about to create a firmware file for writing</span>
</span><span class="hll">    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">);</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not open %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">);</span>
</span><span class="hll">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="c1">// We&#39;ve succeeded</span>
</span><span class="hll">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
</span><span class="hll">    <span class="c1">// We only need to write to file and check if that succeeded</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Writing to firmware image failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="hll">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll"><span class="p">}</span>
</span><span class="hll">
</span><span class="hll"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_finish</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
</span><span class="hll">    <span class="n">assert</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">))</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Closing firmware image failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class="hll">        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll"><span class="p">}</span>
</span></pre></div>
</div>
<p>Next in queue is <code class="docutils literal notranslate"><span class="pre">fw_reset</span></code>, which is called when something on the Client or
the Server side goes wrong, or if the Server decides to not perform firmware
update. We can implement it as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">fw_reset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Reset can be issued even if the download never started.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We ignore the result code of fclose(), as fw_reset() can&#39;t fail.</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">fclose</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">);</span>
        <span class="c1">// and reset our global state to initial value.</span>
        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Finally, let&#39;s remove any downloaded payload</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And finally, <code class="docutils literal notranslate"><span class="pre">fw_perform_upgrade</span></code> as well as <code class="docutils literal notranslate"><span class="pre">fw_update_install</span></code> are to
be implemented. However, up to this point, we did not specify what would
the format of a downloaded image be, nor how would it be applied.</p>
<p>In our simplified example, we can require from the image to be an executable,
and then in <code class="docutils literal notranslate"><span class="pre">fw_perform_upgrade</span></code> we could be using <code class="docutils literal notranslate"><span class="pre">execl()</span></code> to start a
new (downloaded) version of our Client.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In a more realistic scenario, one would be doing things such as:</p>
<blockquote class="last">
<div><ul class="simple">
<li>firmware verification,</li>
<li>saving it to some persistent storage (e.g. flash), rather than to <code class="docutils literal notranslate"><span class="pre">/tmp</span></code>,</li>
<li>other platform specific stuff.</li>
</ul>
</div></blockquote>
</div>
<p>The other important thing to consider is this: how’s the newly running
client going to know it was upgraded? After all, it would be nice if the
Client could report this information to the Server for it to know the update
actually succeeded.</p>
<p>The simplest solution here is to use a “marker” file, indicating the client successfully
upgraded. Specifically, the idea is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>just before performing the upgrade, a “marker” file is created,</li>
<li>the logic in the Client can check for the existence of the “marker” and conclude,
if the upgrade was performed or not,</li>
<li>finally, the “marker” gets removed.</li>
</ul>
</div></blockquote>
<p>The code is self explanatory:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A part of a rather simple logic checking if the firmware update was</span>
<span class="c1">// successfully performed.</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FW_UPDATED_MARKER</span> <span class="o">=</span> <span class="s">&quot;/tmp/fw-updated-marker&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_perform_upgrade</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chmod</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="mo">0700</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
                <span class="s">&quot;Could not make firmware executable: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Create a marker file, so that the new process knows it is the &quot;upgraded&quot;</span>
    <span class="c1">// one</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">marker</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marker</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Marker file could not be created</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">marker</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">ENDPOINT_NAME</span><span class="p">);</span>
    <span class="c1">// If the call below succeeds, the firmware is considered as &quot;upgraded&quot;,</span>
    <span class="c1">// and we hope the newly started client registers to the Server.</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">execl</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="n">ENDPOINT_NAME</span><span class="p">,</span>
                 <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;execl() failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="c1">// If we are here, it means execl() failed. Marker file MUST now be removed,</span>
    <span class="c1">// as the firmware update failed.</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">anjay_fw_update_handlers_t</span> <span class="n">HANDLERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">stream_open</span> <span class="o">=</span> <span class="n">fw_stream_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">stream_write</span> <span class="o">=</span> <span class="n">fw_stream_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">stream_finish</span> <span class="o">=</span> <span class="n">fw_stream_finish</span><span class="p">,</span>
    <span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">fw_reset</span><span class="p">,</span>
    <span class="p">.</span><span class="n">perform_upgrade</span> <span class="o">=</span> <span class="n">fw_perform_upgrade</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ENDPOINT_NAME</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">fw_update_install</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">anjay_fw_update_initial_state_t</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">,</span> <span class="n">F_OK</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// marker file exists, it means firmware update succeded!</span>
        <span class="n">state</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">ANJAY_FW_UPDATE_INITIAL_SUCCESS</span><span class="p">;</span>
        <span class="n">unlink</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// install the module, pass handlers that we implemented and initial state</span>
    <span class="c1">// that we discovered upon startup</span>
    <span class="k">return</span> <span class="n">anjay_fw_update_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">HANDLERS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="FU3.html" class="btn btn-neutral float-right" title="6.3. Download modes and protocols" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="FU1.html" class="btn btn-neutral float-left" title="6.1. Firmware Update" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, AVSystem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>