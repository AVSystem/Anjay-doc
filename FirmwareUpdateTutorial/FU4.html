

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.4. Secure downloads &mdash; Anjay 2.4.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.5. Poor network connectivity" href="FU5.html" />
    <link rel="prev" title="6.3. Download modes and protocols" href="FU3.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Anjay
          

          
          </a>

          
            
            
              <div class="version">
                2.4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LwM2M.html">2. OMA LwM2M - Brief description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Compiling_client_applications.html">3. Compiling client applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../BasicClient.html">4. Basic client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdvancedTopics.html">5. Advanced topics</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../FirmwareUpdateTutorial.html">6. Firmware Update Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="FU1.html">6.1. Firmware Update</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU2.html">6.2. Basic implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU3.html">6.3. Download modes and protocols</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.4. Secure downloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU5.html">6.5. Poor network connectivity</a></li>
<li class="toctree-l2"><a class="reference internal" href="FU6.html">6.6. Download resumption</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Tools.html">7. Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PortingGuideForNonPOSIXPlatforms.html">8. Porting guide for non-POSIX platforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Migrating.html">9. Migrating from older versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Commercial_support.html">10. Commercial support</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Anjay</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../FirmwareUpdateTutorial.html">6. Firmware Update Tutorial</a> &raquo;</li>
        
      <li>6.4. Secure downloads</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/FirmwareUpdateTutorial/FU4.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="secure-downloads">
<h1>6.4. Secure downloads<a class="headerlink" href="#secure-downloads" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>6.4.1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Up until now, we developed a basic client application that’s capable of
downloading firmware in <strong>PUSH</strong> and <strong>PULL</strong> modes. If the Server connection
is secure, then of course any <strong>PUSH</strong> transfer is automatically secured. In
case of <strong>PULL</strong> mode, however, there remains a question about the source
of credentials required to establishing the secure connection.</p>
<p>In this chapter, we will focus on methods of credentials configuration for
<strong>PULL</strong> mode transfers.</p>
</div>
<div class="section" id="two-ways-of-security-configuration">
<h2>6.4.2. Two ways of security configuration<a class="headerlink" href="#two-ways-of-security-configuration" title="Permalink to this headline">¶</a></h2>
<p>When a secure firmware transfer is initiated, firmware update module implemented
in Anjay gets security configuration in one of two following ways.</p>
<ol class="arabic simple">
<li>If the user implements a <code class="docutils literal notranslate"><span class="pre">get_security_config</span></code> callback located in
<code class="docutils literal notranslate"><span class="pre">anjay_fw_update_handlers_t</span></code>, it is expected to provide the library with
security information.</li>
<li>Otherwise, the library looks through Security Object instances, matching
the download URI host with configured URI in Security Object Instance. When
the matching Instance is found, the security information from that instance
is used. When no match is found, the download fails.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It may seem as the described methods are mutually
exclusive. However, in <code class="docutils literal notranslate"><span class="pre">get_security_config</span></code> callback one can use
<code class="docutils literal notranslate"><span class="pre">anjay_fw_update_load_security_from_dm()</span></code> to attempt URI matching
with entities already configured in Security Object Instances.</p>
</div>
</div>
<div class="section" id="supported-security-modes">
<h2>6.4.3. Supported security modes<a class="headerlink" href="#supported-security-modes" title="Permalink to this headline">¶</a></h2>
<p>The download can be secured by either <a class="reference external" href="https://en.wikipedia.org/wiki/Pre-shared_key">PSK</a>, or by <a class="reference external" href="https://en.wikipedia.org/wiki/Public_key_certificate">Public key
certificates</a>.</p>
<p>Security information is configured in Anjay through a structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * DTLS keys or certificates.</span>
<span class="cm">     */</span>
    <span class="n">avs_net_security_info_t</span> <span class="n">security_info</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * TLS ciphersuites to use.</span>
<span class="cm">     *</span>
<span class="cm">     * A value with &lt;c&gt;num_ids == 0&lt;/c&gt; (default) will cause defaults configured</span>
<span class="cm">     * through &lt;c&gt;anjay_configuration_t::default_tls_ciphersuites&lt;/c&gt;</span>
<span class="cm">     * to be used.</span>
<span class="cm">     */</span>
    <span class="n">avs_net_socket_tls_ciphersuites_t</span> <span class="n">tls_ciphersuites</span><span class="p">;</span>
<span class="p">}</span> <span class="n">anjay_security_config_t</span><span class="p">;</span>
</pre></div>
</div>
<p>And specifically, it’s the <code class="docutils literal notranslate"><span class="pre">security_info</span></code> field that is of interest to
us. <code class="docutils literal notranslate"><span class="pre">avs_net_security_info_t</span></code> can be configured by:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">avs_net_security_info_from_psk()</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">avs_net_security_info_from_certificates()</span></code>.</li>
</ul>
<p>We will now have a closer look at both of these methods.</p>
<div class="section" id="configuration-of-psk">
<h3>6.4.3.1. Configuration of PSK<a class="headerlink" href="#configuration-of-psk" title="Permalink to this headline">¶</a></h3>
<p>This is the most straightforward. The structure representing the PSK
configuration is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * A PSK/identity pair with borrowed pointers. avs_commons will never attempt</span>
<span class="cm"> * to modify these values.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">psk</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">psk_size</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">identity</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">identity_size</span><span class="p">;</span>
<span class="p">}</span> <span class="n">avs_net_psk_info_t</span><span class="p">;</span>
</pre></div>
</div>
<p>After we correctly populated it, we may use:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">avs_net_security_info_t</span> <span class="nf">avs_net_security_info_from_psk</span><span class="p">(</span><span class="n">avs_net_psk_info_t</span> <span class="n">psk</span><span class="p">);</span>
</pre></div>
</div>
<p>to convert <code class="docutils literal notranslate"><span class="pre">avs_net_psk_info_t</span></code> into <code class="docutils literal notranslate"><span class="pre">avs_net_security_info_t</span></code>, as in
the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">avs_net_psk_info_t</span> <span class="n">psk_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">psk</span> <span class="o">=</span> <span class="s">&quot;shared-key&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">psk_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;shared-key&quot;</span><span class="p">),</span>
    <span class="p">.</span><span class="n">identity</span> <span class="o">=</span> <span class="s">&quot;our-identity&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">identity_size</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;our-identity&quot;</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">avs_net_security_info_t</span> <span class="n">psk_security</span> <span class="o">=</span>
    <span class="n">avs_net_security_info_from_psk</span><span class="p">(</span><span class="n">psk_info</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration-of-certificates">
<h3>6.4.3.2. Configuration of Certificates<a class="headerlink" href="#configuration-of-certificates" title="Permalink to this headline">¶</a></h3>
<p>That’s a bit more involving. The structure representing Certificate configuration
is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Certificate and key information may be read from files or passed as raw data.</span>
<span class="cm"> *</span>
<span class="cm"> * User should initialize:</span>
<span class="cm"> *  - @ref avs_net_certificate_info_t#client_cert,</span>
<span class="cm"> *  - @ref avs_net_certificate_info_t#client_key,</span>
<span class="cm"> *  - @ref avs_net_certificate_info_t#trusted_certs</span>
<span class="cm"> * via helper functions:</span>
<span class="cm"> *  - @ref avs_net_client_cert_from_*</span>
<span class="cm"> *  - @ref avs_net_client_key_from_*</span>
<span class="cm"> *  - @ref avs_net_trusted_cert_source_from_*</span>
<span class="cm"> *</span>
<span class="cm"> * Moreover, to enable CA chain validation one MUST set @ref</span>
<span class="cm"> * avs_net_certificate_info_t#server_cert_validation to true.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">server_cert_validation</span><span class="p">;</span>
    <span class="n">avs_net_trusted_cert_info_t</span> <span class="n">trusted_certs</span><span class="p">;</span>
    <span class="n">avs_net_client_cert_info_t</span> <span class="n">client_cert</span><span class="p">;</span>
    <span class="n">avs_net_client_key_info_t</span> <span class="n">client_key</span><span class="p">;</span>
<span class="p">}</span> <span class="n">avs_net_certificate_info_t</span><span class="p">;</span>
</pre></div>
</div>
<p>To populate it properly, we’re gonna need at least two pieces of information
from the following list:</p>
<ul class="simple">
<li>Trusted Certificates, also known as CA / Root certificates (required only
if we intend to verify certificates presented to us by the Server; although
it’s optional it is <strong>highly recommended</strong>),</li>
<li>Client Certificate, which is <strong>required</strong>,</li>
<li>Client Private Key, which is also <strong>required</strong>.</li>
</ul>
<p>Each of them come in variety of formats (text, binary, etc.) that need to
be loaded and parsed. In most scenarios however, the API provided by <cite>avs_commons</cite>
would suffice to do the necessary work.</p>
<p>For example, to configure Certificate based security, loading all information
from files, we could do something like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">avs_net_certificate_info_t</span> <span class="n">cert_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">server_cert_validation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="p">.</span><span class="n">trusted_certs</span> <span class="o">=</span> <span class="n">avs_net_trusted_cert_info_from_path</span><span class="p">(</span><span class="s">&quot;./CA.crt&quot;</span><span class="p">),</span>
    <span class="p">.</span><span class="n">client_cert</span> <span class="o">=</span> <span class="n">avs_net_client_cert_info_from_file</span><span class="p">(</span><span class="s">&quot;./client.crt&quot;</span><span class="p">),</span>
    <span class="c1">// NOTE: &quot;password&quot; may be NULL if no password is required</span>
    <span class="p">.</span><span class="n">client_key</span> <span class="o">=</span> <span class="n">avs_net_client_key_info_from_file</span><span class="p">(</span><span class="s">&quot;./client.key&quot;</span><span class="p">,</span> <span class="s">&quot;password&quot;</span><span class="p">)</span>
<span class="p">};</span>
<span class="n">avs_net_security_info_t</span> <span class="n">cert_security</span> <span class="o">=</span>
    <span class="n">avs_net_security_info_from_certificates</span><span class="p">(</span><span class="n">cert_info</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="security-configuration-with-get-security-config-callback">
<h2>6.4.4. Security configuration with <code class="docutils literal notranslate"><span class="pre">get_security_config</span></code> callback<a class="headerlink" href="#security-configuration-with-get-security-config-callback" title="Permalink to this headline">¶</a></h2>
<p>Firmware update module provided with Anjay, lets the user implement security
configuration per download URI. The relevant API is:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="kt">int</span> <span class="nf">anjay_fw_update_get_security_config_t</span><span class="p">(</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span>
        <span class="n">anjay_security_config_t</span> <span class="o">*</span><span class="n">out_security_info</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">download_uri</span><span class="p">);</span>
</pre></div>
</div>
<p>And the corresponding handler in <code class="docutils literal notranslate"><span class="pre">anjay_fw_update_handlers_t</span></code> to be implemented
by the user:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/** Opens the stream that will be used to write the firmware package to;</span>
<span class="cm">     * @ref anjay_fw_update_stream_open_t */</span>
    <span class="n">anjay_fw_update_stream_open_t</span> <span class="o">*</span><span class="n">stream_open</span><span class="p">;</span>
    <span class="cm">/** Writes data to the download stream;</span>
<span class="cm">     * @ref anjay_fw_update_stream_write_t */</span>
    <span class="n">anjay_fw_update_stream_write_t</span> <span class="o">*</span><span class="n">stream_write</span><span class="p">;</span>
    <span class="cm">/** Closes the download stream and prepares the firmware package to be</span>
<span class="cm">     * flashed; @ref anjay_fw_update_stream_finish_t */</span>
    <span class="n">anjay_fw_update_stream_finish_t</span> <span class="o">*</span><span class="n">stream_finish</span><span class="p">;</span>

    <span class="cm">/** Resets the firmware update state and performs any applicable cleanup of</span>
<span class="cm">     * temporary storage if necessary; @ref anjay_fw_update_reset_t */</span>
    <span class="n">anjay_fw_update_reset_t</span> <span class="o">*</span><span class="n">reset</span><span class="p">;</span>

    <span class="cm">/** Returns the name of downloaded firmware package;</span>
<span class="cm">     * @ref anjay_fw_update_get_name_t */</span>
    <span class="n">anjay_fw_update_get_name_t</span> <span class="o">*</span><span class="n">get_name</span><span class="p">;</span>
    <span class="cm">/** Return the version of downloaded firmware package;</span>
<span class="cm">     * @ref anjay_fw_update_get_version_t */</span>
    <span class="n">anjay_fw_update_get_version_t</span> <span class="o">*</span><span class="n">get_version</span><span class="p">;</span>

    <span class="cm">/** Performs the actual upgrade with previously downloaded package;</span>
<span class="cm">     * @ref anjay_fw_update_perform_upgrade_t */</span>
    <span class="n">anjay_fw_update_perform_upgrade_t</span> <span class="o">*</span><span class="n">perform_upgrade</span><span class="p">;</span>

<span class="hll">    <span class="cm">/** Queries security configuration that shall be used for an encrypted</span>
</span><span class="hll"><span class="cm">     * connection; @ref anjay_fw_update_get_security_config_t */</span>
</span><span class="hll">    <span class="n">anjay_fw_update_get_security_config_t</span> <span class="o">*</span><span class="n">get_security_config</span><span class="p">;</span>
</span>
    <span class="cm">/** Queries CoAP transmission parameters to be used during firmware</span>
<span class="cm">     * update. */</span>
    <span class="n">anjay_fw_update_get_coap_tx_params_t</span> <span class="o">*</span><span class="n">get_coap_tx_params</span><span class="p">;</span>
<span class="p">}</span> <span class="n">anjay_fw_update_handlers_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Now, the <code class="docutils literal notranslate"><span class="pre">anjay_fw_update_get_security_config_t</span></code> job is to fill
<code class="docutils literal notranslate"><span class="pre">anjay_security_config_t</span></code> properly. This structure consists of two fields:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * DTLS keys or certificates.</span>
<span class="cm">     */</span>
    <span class="n">avs_net_security_info_t</span> <span class="n">security_info</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * TLS ciphersuites to use.</span>
<span class="cm">     *</span>
<span class="cm">     * A value with &lt;c&gt;num_ids == 0&lt;/c&gt; (default) will cause defaults configured</span>
<span class="cm">     * through &lt;c&gt;anjay_configuration_t::default_tls_ciphersuites&lt;/c&gt;</span>
<span class="cm">     * to be used.</span>
<span class="cm">     */</span>
    <span class="n">avs_net_socket_tls_ciphersuites_t</span> <span class="n">tls_ciphersuites</span><span class="p">;</span>
<span class="p">}</span> <span class="n">anjay_security_config_t</span><span class="p">;</span>
</pre></div>
</div>
<p>We’ve already seen in previous sections how to configure
<code class="docutils literal notranslate"><span class="pre">security_info</span></code>. Also, for now there is no need to worry about
<code class="docutils literal notranslate"><span class="pre">tls_ciphersuites</span></code> - they can be reset to zero.</p>
</div>
<div class="section" id="implementation">
<h2>6.4.5. Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>Our implementation will use the following strategy:</p>
<ol class="arabic simple">
<li>Try loading security info from the data model first (i.e. Security Object).</li>
<li>If that failed, attempt loading certificates from predefined paths.</li>
</ol>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>Before we jump into implementation, there’s one more important thing
to keep in mind: the lifetime of <code class="docutils literal notranslate"><span class="pre">anjay_security_config_t</span></code>
fields. Failing to satisfy lifetime requirements will be met with
undefined behavior.</p>
<p class="last">The fields of <code class="docutils literal notranslate"><span class="pre">anjay_security_config_t</span></code> contain references to file
paths, binary security keys, and/or ciphersuite lists. After our
<code class="docutils literal notranslate"><span class="pre">get_security_config</span></code> is called, they are not immediately stored
anywhere, and for that reason we need to ensure their lifetime is as
long as necessary. The documentation describes this in more detail,
and we recommend to have a glance at it.</p>
</div>
<p>Our simplified implementation uses either
<code class="docutils literal notranslate"><span class="pre">anjay_fw_update_load_security_from_dm()</span></code> which already returns a pointer
to the heap allocated space, or when the fallback to certificates is needed,
only literal c-strings are used, thus the lifetime of security configuration
in both cases is just right.</p>
<p>The implementation is presented below. Changes made since <a class="reference internal" href="FU2.html"><span class="doc">last time</span></a>
are highlighted:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;./firmware_update.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fw_state_t</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">firmware_file</span><span class="p">;</span>
<span class="hll">    <span class="c1">// anjay instance this firmware update singleton is associated with</span>
</span><span class="hll">    <span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">;</span>
</span><span class="hll">    <span class="c1">// pointer to configuration loaded from data model, we need to keep it</span>
</span><span class="hll">    <span class="c1">// to be able to avs_free() it later</span>
</span><span class="hll">    <span class="n">anjay_security_config_t</span> <span class="o">*</span><span class="n">dm_security_config</span><span class="p">;</span>
</span><span class="p">}</span> <span class="n">FW_STATE</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span> <span class="o">=</span> <span class="s">&quot;/tmp/firmware_image.bin&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_open</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span>
                          <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">package_uri</span><span class="p">,</span>
                          <span class="k">const</span> <span class="k">struct</span> <span class="n">anjay_etag</span> <span class="o">*</span><span class="n">package_etag</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// For a moment, we don&#39;t need to care about any of the arguments passed.</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">package_uri</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">package_etag</span><span class="p">;</span>

    <span class="c1">// It&#39;s worth ensuring we start with a NULL firmware_file. In the end</span>
    <span class="c1">// it would be our responsibility to manage this pointer, and we want</span>
    <span class="c1">// to make sure we never leak any memory.</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// We&#39;re about to create a firmware file for writing</span>
    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="s">&quot;wb&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not open %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// We&#39;ve succeeded</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_write</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
    <span class="c1">// We only need to write to file and check if that succeeded</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fwrite</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Writing to firmware image failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_stream_finish</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Closing firmware image failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fw_reset</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Reset can be issued even if the download never started.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// We ignore the result code of fclose(), as fw_reset() can&#39;t fail.</span>
        <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">fclose</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span><span class="p">);</span>
        <span class="c1">// and reset our global state to initial value.</span>
        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">firmware_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">avs_free</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">);</span>
</span><span class="hll">        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span>    <span class="c1">// Finally, let&#39;s remove any downloaded payload</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// A part of a rather simple logic checking if the firmware update was</span>
<span class="c1">// successfully performed.</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FW_UPDATED_MARKER</span> <span class="o">=</span> <span class="s">&quot;/tmp/fw-updated-marker&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_perform_upgrade</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chmod</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="mo">0700</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span>
                <span class="s">&quot;Could not make firmware executable: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Create a marker file, so that the new process knows it is the &quot;upgraded&quot;</span>
    <span class="c1">// one</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">marker</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">marker</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Marker file could not be created</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">marker</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">ENDPOINT_NAME</span><span class="p">);</span>
    <span class="c1">// If the call below succeeds, the firmware is considered as &quot;upgraded&quot;,</span>
    <span class="c1">// and we hope the newly started client registers to the Server.</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">execl</span><span class="p">(</span><span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="n">FW_IMAGE_DOWNLOAD_NAME</span><span class="p">,</span> <span class="n">ENDPOINT_NAME</span><span class="p">,</span>
                 <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;execl() failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
    <span class="c1">// If we are here, it means execl() failed. Marker file MUST now be removed,</span>
    <span class="c1">// as the firmware update failed.</span>
    <span class="n">unlink</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="hll"><span class="k">static</span> <span class="kt">int</span> <span class="nf">fw_get_security_config</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">user_ptr</span><span class="p">,</span>
</span><span class="hll">                                <span class="n">anjay_security_config_t</span> <span class="o">*</span><span class="n">out_security_info</span><span class="p">,</span>
</span><span class="hll">                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">download_uri</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">user_ptr</span><span class="p">;</span>
</span><span class="hll">    <span class="n">memset</span><span class="p">(</span><span class="n">out_security_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out_security_info</span><span class="p">));</span>
</span><span class="hll">
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="n">avs_free</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">);</span>
</span><span class="hll">        <span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span> <span class="o">=</span>
</span><span class="hll">            <span class="n">anjay_fw_update_load_security_from_dm</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">anjay</span><span class="p">,</span> <span class="n">download_uri</span><span class="p">);</span>
</span><span class="hll">    <span class="k">if</span> <span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">)</span> <span class="p">{</span>
</span><span class="hll">        <span class="c1">// found a match</span>
</span><span class="hll">        <span class="n">memcpy</span><span class="p">(</span><span class="n">out_security_info</span><span class="p">,</span>
</span><span class="hll">            <span class="n">FW_STATE</span><span class="p">.</span><span class="n">dm_security_config</span><span class="p">,</span>
</span><span class="hll">            <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out_security_info</span><span class="p">));</span>
</span><span class="hll">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll">    <span class="p">}</span>
</span><span class="hll">    <span class="c1">// no match found, fallback to loading certificates from given paths</span>
</span><span class="hll">    <span class="k">const</span> <span class="n">avs_net_certificate_info_t</span> <span class="n">cert_info</span> <span class="o">=</span> <span class="p">{</span>
</span><span class="hll">        <span class="p">.</span><span class="n">server_cert_validation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
</span><span class="hll">        <span class="p">.</span><span class="n">trusted_certs</span> <span class="o">=</span> <span class="n">avs_net_trusted_cert_info_from_path</span><span class="p">(</span><span class="s">&quot;./certs/CA.crt&quot;</span><span class="p">),</span>
</span><span class="hll">        <span class="p">.</span><span class="n">client_cert</span> <span class="o">=</span> <span class="n">avs_net_client_cert_info_from_file</span><span class="p">(</span><span class="s">&quot;./certs/client.crt&quot;</span><span class="p">),</span>
</span><span class="hll">        <span class="p">.</span><span class="n">client_key</span> <span class="o">=</span>
</span><span class="hll">                <span class="n">avs_net_client_key_info_from_file</span><span class="p">(</span><span class="s">&quot;./certs/client.key&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="hll">    <span class="p">};</span>
</span><span class="hll">    <span class="c1">// NOTE: this assignment is safe, because cert_info contains pointers to</span>
</span><span class="hll">    <span class="c1">// string literals only. If the configuration were to load certificate info</span>
</span><span class="hll">    <span class="c1">// from buffers they would have to be stored somewhere - e.g. on the heap.</span>
</span><span class="hll">    <span class="n">out_security_info</span><span class="o">-&gt;</span><span class="n">security_info</span> <span class="o">=</span>
</span><span class="hll">            <span class="n">avs_net_security_info_from_certificates</span><span class="p">(</span><span class="n">cert_info</span><span class="p">);</span>
</span><span class="hll">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="hll"><span class="p">}</span>
</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">anjay_fw_update_handlers_t</span> <span class="n">HANDLERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">stream_open</span> <span class="o">=</span> <span class="n">fw_stream_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">stream_write</span> <span class="o">=</span> <span class="n">fw_stream_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">stream_finish</span> <span class="o">=</span> <span class="n">fw_stream_finish</span><span class="p">,</span>
    <span class="p">.</span><span class="n">reset</span> <span class="o">=</span> <span class="n">fw_reset</span><span class="p">,</span>
<span class="hll">    <span class="p">.</span><span class="n">perform_upgrade</span> <span class="o">=</span> <span class="n">fw_perform_upgrade</span><span class="p">,</span>
</span>    <span class="p">.</span><span class="n">get_security_config</span> <span class="o">=</span> <span class="n">fw_get_security_config</span>
<span class="p">};</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ENDPOINT_NAME</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">fw_update_install</span><span class="p">(</span><span class="n">anjay_t</span> <span class="o">*</span><span class="n">anjay</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">anjay_fw_update_initial_state_t</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">state</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">access</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">,</span> <span class="n">F_OK</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// marker file exists, it means firmware update succeded!</span>
        <span class="n">state</span><span class="p">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">ANJAY_FW_UPDATE_INITIAL_SUCCESS</span><span class="p">;</span>
        <span class="n">unlink</span><span class="p">(</span><span class="n">FW_UPDATED_MARKER</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// make sure this module is installed for single Anjay instance only</span>
<span class="hll">    <span class="n">assert</span><span class="p">(</span><span class="n">FW_STATE</span><span class="p">.</span><span class="n">anjay</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="hll">    <span class="n">FW_STATE</span><span class="p">.</span><span class="n">anjay</span> <span class="o">=</span> <span class="n">anjay</span><span class="p">;</span>
</span><span class="hll">    <span class="c1">// install the module, pass handlers that we implemented and initial state</span>
</span>    <span class="c1">// that we discovered upon startup</span>
    <span class="k">return</span> <span class="n">anjay_fw_update_install</span><span class="p">(</span><span class="n">anjay</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">HANDLERS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="FU5.html" class="btn btn-neutral float-right" title="6.5. Poor network connectivity" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="FU3.html" class="btn btn-neutral float-left" title="6.3. Download modes and protocols" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, AVSystem

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>