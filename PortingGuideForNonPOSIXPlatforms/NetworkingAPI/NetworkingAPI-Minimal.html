<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>8.3.1.1. Minimal socket implementation &mdash; Anjay 3.6.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="8.3.1.2. Get remote host/port operations" href="NetworkingAPI-RemoteHostPort.html" />
    <link rel="prev" title="8.3. Networking API" href="../NetworkingAPI.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #ffd500" >
            <a href="../../index.html">
            <img src="../../_static/avsystem_header.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.6.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LwM2M.html">2. OMA LwM2M - Brief description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Compiling_client_applications.html">3. Compiling client applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../BasicClient.html">4. Basic client</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../AdvancedTopics.html">5. Advanced topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../FirmwareUpdateTutorial.html">6. Firmware Update Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tools.html">7. Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../PortingGuideForNonPOSIXPlatforms.html">8. Porting guide for non-POSIX platforms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../TimeAPI.html">8.1. Time API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ThreadingAPI.html">8.2. Threading API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../NetworkingAPI.html">8.3. Networking API</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">8.3.1.1. Minimal socket implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-RemoteHostPort.html">8.3.1.2. Get remote host/port operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-Bind.html">8.3.1.3. Bind operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-ShutdownRemoteHostname.html">8.3.1.4. Remote hostname and shutdown operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-Stats.html">8.3.1.5. Statistics support</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-IpStickiness.html">8.3.1.6. IP address stickiness support</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-EventLoopSupport.html">8.3.1.7. Event loop support</a></li>
<li class="toctree-l3"><a class="reference internal" href="NetworkingAPI-OtherFeatures.html">8.3.1.8. Other features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../CustomTLS.html">8.4. Custom (D)TLS layers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Migrating.html">9. Migrating from older versions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CommercialFeatures.html">10. Commercial features</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #ffd500" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Anjay</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../PortingGuideForNonPOSIXPlatforms.html"><span class="section-number">8. </span>Porting guide for non-POSIX platforms</a> &raquo;</li>
          <li><a href="../NetworkingAPI.html"><span class="section-number">8.3. </span>Networking API</a> &raquo;</li>
      <li><span class="section-number">8.3.1.1. </span>Minimal socket implementation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="minimal-socket-implementation">
<h1><span class="section-number">8.3.1.1. </span>Minimal socket implementation<a class="headerlink" href="#minimal-socket-implementation" title="Permalink to this headline"></a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id1">Introduction</a></p></li>
<li><p><a class="reference internal" href="#adjustments-to-the-build-system" id="id2">Adjustments to the build system</a></p></li>
<li><p><a class="reference internal" href="#global-initialization" id="id3">Global initialization</a></p></li>
<li><p><a class="reference internal" href="#socket-creation" id="id4">Socket creation</a></p></li>
<li><p><a class="reference internal" href="#implementing-socket-methods" id="id5">Implementing socket methods</a></p>
<ul>
<li><p><a class="reference internal" href="#connect" id="id6">Connect</a></p></li>
<li><p><a class="reference internal" href="#send" id="id7">Send</a></p></li>
<li><p><a class="reference internal" href="#receive" id="id8">Receive</a></p></li>
<li><p><a class="reference internal" href="#close" id="id9">Close</a></p></li>
<li><p><a class="reference internal" href="#cleanup" id="id10">Cleanup</a></p></li>
<li><p><a class="reference internal" href="#get-system-socket" id="id11">Get system socket</a></p></li>
<li><p><a class="reference internal" href="#get-set-socket-options" id="id12">Get/set socket options</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#limitations" id="id13">Limitations</a></p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Code related to this tutorial can be found under
<a class="reference external" href="https://github.com/AVSystem/Anjay/tree/master/examples/custom-network/minimal">examples/custom-network/minimal</a>
in the Anjay source directory.</p>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id1"><span class="section-number">8.3.1.1.1. </span>Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>This tutorial builds up on the <a class="reference internal" href="../../BasicClient/BC-Security.html"><span class="doc">Enabling secure communication</span></a> tutorial
which contains an implementation of a minimal, but complete LwM2M client.</p>
<p>However, this tutorial is intended to be used with a version of Anjay that has
been compiled without the default network layer implementation, i.e. with these
additional CMake flags:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">DWITH_POSIX_AVS_SOCKET</span><span class="o">=</span><span class="n">OFF</span>
<span class="o">-</span><span class="n">DWITHOUT_IP_STICKINESS</span><span class="o">=</span><span class="n">ON</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new custom network layer implementation will be based on the POSIX
socket APIs. This is not very useful in the real world, as the default
implementation works fine in such environment. However, this tutorial is
provided as a reference implementation simpler than the actual default one,
to make it easier to base your code on it.</p>
</div>
</section>
<section id="adjustments-to-the-build-system">
<h2><a class="toc-backref" href="#id2"><span class="section-number">8.3.1.1.2. </span>Adjustments to the build system</a><a class="headerlink" href="#adjustments-to-the-build-system" title="Permalink to this headline"></a></h2>
<p>The <a class="reference external" href="https://github.com/AVSystem/Anjay/blob/master/examples/custom-network/minimal/CMakeLists.txt">CMakeLists.txt</a>
file has been modified to accommodate for this custom network layer:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span><span class="w"> </span><span class="s">3.1</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">minimal-custom-network</span><span class="w"> </span><span class="s">C</span><span class="p">)</span>

<span class="hll"><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_C_STANDARD</span><span class="w"> </span><span class="s">99</span><span class="p">)</span>
</span>
<span class="nb">find_package</span><span class="p">(</span><span class="s">anjay</span><span class="w"> </span><span class="s">REQUIRED</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
<span class="w">               </span><span class="s">src/main.c</span>
<span class="hll"><span class="w">               </span><span class="s">src/net_impl.c</span><span class="p">)</span>
</span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span><span class="w"> </span><span class="s">PRIVATE</span><span class="w"> </span><span class="s">anjay</span><span class="p">)</span>
</pre></div>
</div>
<p>Two changes has been made here:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">set(CMAKE_C_EXTENSIONS</span> <span class="pre">OFF)</span></code> setting has been removed. This is because
we will need to use POSIX APIs, which are considered extensions to the C
standard and would not compile with this flag set.</p></li>
<li><p>The <a class="reference external" href="https://github.com/AVSystem/Anjay/blob/master/examples/custom-network/minimal/src/net_impl.c">net_impl.c</a>
file has been added to the executable target. Note that the functions defined
there will be called by Anjay or its dependent libraries, so, in a way, in
addition to the normal dependency of the application on the library, the
opposite is also true - parts of the library depends on the application as
well.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">main.c</span></code> is left completely unchanged compared to the
<a class="reference internal" href="../../BasicClient/BC-Security.html"><span class="doc">Enabling secure communication</span></a> version. In fact, in the repository,
it is a symbolic link to the file from that tutorial.</p>
</div>
</section>
<section id="global-initialization">
<h2><a class="toc-backref" href="#id3"><span class="section-number">8.3.1.1.3. </span>Global initialization</a><a class="headerlink" href="#global-initialization" title="Permalink to this headline"></a></h2>
<p>The APIs that need to be implemented are private, so there is no public header
that can be included to provide forward declarations of them. Hence, we start
with manually including the forward declarations, as quoted in the
<a class="reference internal" href="../NetworkingAPI.html"><span class="doc">previous article</span></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_initialize_global_compat_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">_avs_net_cleanup_global_compat_state</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_create_tcp_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">socket</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">socket_configuration</span><span class="p">);</span>
<span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_create_udp_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">socket</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">socket_configuration</span><span class="p">);</span>
</pre></div>
</div>
<p>We actually won’t need any global state for our implementation, so implementing
the <code class="docutils literal notranslate"><span class="pre">_avs_net_{initialize,cleanup}_global_compat_state()</span></code> functions is
trivial:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_initialize_global_compat_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">_avs_net_cleanup_global_compat_state</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<p>Global state may be useful on some platforms where using the network requires
some global initialization. For example on Windows, this is the right place to
call <code class="docutils literal notranslate"><span class="pre">WSAStartup()</span></code> and <code class="docutils literal notranslate"><span class="pre">WSACleanup()</span></code>.</p>
<p>On embedded platforms, initialization of network interfaces might also go here,
although typically this is done in the main function, before calling any of the
Anjay APIs and the network layer implementation assumes that the interface has
already been initialized.</p>
</section>
<section id="socket-creation">
<span id="non-posix-networking-api-create"></span><h2><a class="toc-backref" href="#id4"><span class="section-number">8.3.1.1.4. </span>Socket creation</a><a class="headerlink" href="#socket-creation" title="Permalink to this headline"></a></h2>
<p>Some platforms that handle TCP and UDP communication with completely different
APIs (<a class="reference external" href="https://www.mbed.com/en/platform/mbed-os/">Mbed OS</a> being one such
example), will require completely separate code to implement TCP and UDP
communication - or you might choose to implement just one of them, and
implement the other <code class="docutils literal notranslate"><span class="pre">_avs_net_create_*_socket()</span></code> function as a placeholder
that always returns an error code.</p>
<p>With BSD-style socket API, however, it is actually trivial to support both TCP
and UDP sockets, so we will do just that.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">avs_net_socket_v_table_t</span><span class="w"> </span><span class="o">*</span><span class="n">operations</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">socktype</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="w">    </span><span class="n">avs_time_duration_t</span><span class="w"> </span><span class="n">recv_timeout</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">net_socket_impl_t</span><span class="p">;</span>

<span class="c1">// ... implementations of NET_SOCKET_VTABLE functions go here</span>
<span class="c1">// ... they will be discussed separately later</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">avs_net_socket_v_table_t</span><span class="w"> </span><span class="n">NET_SOCKET_VTABLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">connect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_connect</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_send</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">receive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_receive</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">close</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_close</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">cleanup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_cleanup</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">get_system_socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_system_socket</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">get_opt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_get_opt</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">set_opt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_set_opt</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span>
<span class="nf">net_create_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">socket_ptr</span><span class="p">,</span>
<span class="w">                  </span><span class="k">const</span><span class="w"> </span><span class="n">avs_net_socket_configuration_t</span><span class="w"> </span><span class="o">*</span><span class="n">configuration</span><span class="p">,</span>
<span class="w">                  </span><span class="kt">int</span><span class="w"> </span><span class="n">socktype</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">socket_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="o">!*</span><span class="n">socket_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">configuration</span><span class="p">;</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">socket</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">avs_calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">socket</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_ENOMEM</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">operations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">NET_SOCKET_VTABLE</span><span class="p">;</span>
<span class="w">    </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">socktype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socktype</span><span class="p">;</span>
<span class="w">    </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">socket</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avs_time_duration_from_scalar</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="n">AVS_TIME_S</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">socket_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">socket</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_create_udp_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">socket_ptr</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">configuration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">net_create_socket</span><span class="p">(</span>
<span class="w">            </span><span class="n">socket_ptr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">avs_net_socket_configuration_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">configuration</span><span class="p">,</span>
<span class="w">            </span><span class="n">SOCK_DGRAM</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">avs_error_t</span><span class="w"> </span><span class="nf">_avs_net_create_tcp_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">socket_ptr</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">configuration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">net_create_socket</span><span class="p">(</span>
<span class="w">            </span><span class="n">socket_ptr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">avs_net_socket_configuration_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">configuration</span><span class="p">,</span>
<span class="w">            </span><span class="n">SOCK_STREAM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">avs_commons</span></code> uses an object-oriented paradigm for its socket layer. Any
socket object needs to be created on the heap - it can be any user-defined
structure, but its first member MUST be a pointer to the
<code class="docutils literal notranslate"><span class="pre">avs_net_socket_v_table_t</span></code> structure. Functions from that structure will be
called as implementations of all the socket operations.</p>
<p>Aside from this <code class="docutils literal notranslate"><span class="pre">vtable</span></code> pointer, this minimal implementation contains the
following fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">socktype</span></code> - either <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> or <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>. The actual
<code class="docutils literal notranslate"><span class="pre">socket()</span></code> call for creating the OS-level socket descriptor will be deferred
until the <code class="docutils literal notranslate"><span class="pre">connect</span></code> operation. At that point we will need to know whether we
need to create a UDP or TCP socket. This will also slightly alter the behavior
of the <code class="docutils literal notranslate"><span class="pre">receive</span></code> method. Thus, we need to store the value, determined at
socket creation time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fd</span></code> - the OS-level file descriptor referring to the actual socket.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">recv_timeout</span></code> - timeout for the <code class="docutils literal notranslate"><span class="pre">receive</span></code> operation. Anjay uses timed
<code class="docutils literal notranslate"><span class="pre">receive</span></code> operation extensively, to provide appropriate retransmission and
timeout behavior on higher layers, as required by the CoAP and LwM2M
protocols. This timeout is controlled by <code class="docutils literal notranslate"><span class="pre">get_opt</span></code> and <code class="docutils literal notranslate"><span class="pre">set_opt</span></code>
operations, so it needs to be stored between method calls.</p></li>
</ul>
<p>The actual <code class="docutils literal notranslate"><span class="pre">_avs_net_create_udp_socket()</span></code> and <code class="docutils literal notranslate"><span class="pre">_avs_net_create_tcp_socket()</span></code>
functions are implemented as thin wrappers to the static <code class="docutils literal notranslate"><span class="pre">net_create_socket</span></code>
function, which allocates the socket object, initializes <code class="docutils literal notranslate"><span class="pre">vtable</span></code> and
<code class="docutils literal notranslate"><span class="pre">socktype</span></code> fields, as well as sets <code class="docutils literal notranslate"><span class="pre">fd</span></code> to <code class="docutils literal notranslate"><span class="pre">-1</span></code> (signifying no OS-level
socket descriptor initialized yet) and initial <code class="docutils literal notranslate"><span class="pre">recv_timeout</span></code> to 30 seconds.</p>
</section>
<section id="implementing-socket-methods">
<h2><a class="toc-backref" href="#id5"><span class="section-number">8.3.1.1.5. </span>Implementing socket methods</a><a class="headerlink" href="#implementing-socket-methods" title="Permalink to this headline"></a></h2>
<section id="connect">
<span id="non-posix-networking-api-connect"></span><h3><a class="toc-backref" href="#id6"><span class="section-number">8.3.1.1.5.1. </span>Connect</a><a class="headerlink" href="#connect" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span>
<span class="nf">net_connect</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">port</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">addrinfo</span><span class="w"> </span><span class="n">hints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">ai_socktype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">socktype</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">getsockopt</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_DOMAIN</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span><span class="p">,</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="p">(</span><span class="kt">socklen_t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span><span class="p">)</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">addrinfo</span><span class="w"> </span><span class="o">*</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="n">avs_error_t</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="n">port</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">addr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_EADDRNOTAVAIL</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span>
<span class="w">               </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">))</span>
<span class="w">                          </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_UNKNOWN_ERROR</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_ECONNREFUSED</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">freeaddrinfo</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In each of the vtable methods, the first <code class="docutils literal notranslate"><span class="pre">avs_net_socket_t</span> <span class="pre">*</span></code> argument is the
“self” pointer. It is intended to be cast to the actual type that has been
allocated for the socket.</p>
<p>To call the POSIX <code class="docutils literal notranslate"><span class="pre">connect()</span></code> function, we need a socket address formatted as
some structure from the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sockaddr</span></code> family. <code class="docutils literal notranslate"><span class="pre">avs_commons</span></code> use strings
for representing TCP/IP endpoint information - <code class="docutils literal notranslate"><span class="pre">host</span></code> can be either a
stringified IP address or a hostname, while <code class="docutils literal notranslate"><span class="pre">port</span></code> is a stringified port
number. This is designed to match the API of the POSIX <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code>
function - as such, it is natural to use it in our implementation.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">hints</span></code> structure, we fill the <code class="docutils literal notranslate"><span class="pre">ai_socktype</span></code> with the type stored at
socket creation time - either <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> or <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>. If the socket
file descriptor has already been created, we also fill <code class="docutils literal notranslate"><span class="pre">ai_family</span></code> with the
socket family (most likely <code class="docutils literal notranslate"><span class="pre">AF_INET</span></code> or <code class="docutils literal notranslate"><span class="pre">AF_INET6</span></code>).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">getaddrinfo()</span></code> fails, we return the <code class="docutils literal notranslate"><span class="pre">avs_errno(AVS_EADDRNOTAVAIL)</span></code> error
code.</p>
<p>Then, we create the socket descriptor if needed, and <code class="docutils literal notranslate"><span class="pre">connect()</span></code> it -
returning the <code class="docutils literal notranslate"><span class="pre">avs_errno(AVS_ECONNREFUSED)</span></code> error code if necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more complete error handling, you can use <code class="docutils literal notranslate"><span class="pre">avs_map_errno(errno)</span></code>
function, declared in <code class="docutils literal notranslate"><span class="pre">avs_errno_map.h</span></code>, to translate and forward the
actual <code class="docutils literal notranslate"><span class="pre">errno</span></code> values to the caller. This tutorial uses hardcoded error
codes for simplicity.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This simplistic code does not implement some features that might be useful:</p>
<ul class="simple">
<li><p>You might want to try connecting to subsequent addresses from the <code class="docutils literal notranslate"><span class="pre">addr</span></code>
list if the first one fails - especially for TCP. Such issues may happen
e.g. when the system has incomplete IPv6 connectivity.</p></li>
<li><p>You might want to implement connecting logic in a more sophisticated way,
e.g. by putting the socket in non-blocking mode and using <code class="docutils literal notranslate"><span class="pre">poll()</span></code> after
<code class="docutils literal notranslate"><span class="pre">connect()</span></code>, to implement better-defined timeout handling when
connecting - especially for TCP.</p></li>
</ul>
</div>
</section>
<section id="send">
<h3><a class="toc-backref" href="#id7"><span class="section-number">8.3.1.1.5.2. </span>Send</a><a class="headerlink" href="#send" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">send()</span></code> implementation is self-explanatory:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span>
<span class="nf">net_send</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">,</span><span class="w"> </span><span class="n">MSG_NOSIGNAL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">written</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="n">written</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_EIO</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>This implementation may behave erroneously for TCP. The POSIX API for
stream-oriented sockets permits so-called “short writes”, i.e. the case
where <code class="docutils literal notranslate"><span class="pre">send()</span></code> writes less data than passed to it is treated as success.
The <code class="docutils literal notranslate"><span class="pre">avs_commons</span></code> API does not - so a proper implementation of this method
for TCP shall call underlying <code class="docutils literal notranslate"><span class="pre">send()</span></code> function in a loop until either all
data is sent, or an error occurs.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For more completeness, you might want to e.g. call <code class="docutils literal notranslate"><span class="pre">poll()</span></code> for the
<code class="docutils literal notranslate"><span class="pre">POLLOUT</span></code> event, to implement better-defined timeout handling when
sending.</p>
</div>
</section>
<section id="receive">
<span id="non-posix-networking-api-receive"></span><h3><a class="toc-backref" href="#id8"><span class="section-number">8.3.1.1.5.3. </span>Receive</a><a class="headerlink" href="#receive" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">net_receive</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">size_t</span><span class="w"> </span><span class="o">*</span><span class="n">out_bytes_received</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">size_t</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">pollfd</span><span class="w"> </span><span class="n">pfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">.</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span>
<span class="w">        </span><span class="p">.</span><span class="n">events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">POLLIN</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">timeout_ms</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avs_time_duration_to_scalar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timeout_ms</span><span class="p">,</span><span class="w"> </span><span class="n">AVS_TIME_MS</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">timeout_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">timeout_ms</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">timeout_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfd</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">timeout_ms</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_ETIMEDOUT</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">bytes_received</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bytes_received</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_EIO</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">out_bytes_received</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="n">bytes_received</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer_length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">socktype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SOCK_DGRAM</span>
<span class="w">            </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="w"> </span><span class="n">bytes_received</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">buffer_length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_EMSGSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Implementation of the receive method is a bit more complicated than that of the
send method, because proper receive timeout handling is essential for Anjay.</p>
<p>That’s why <code class="docutils literal notranslate"><span class="pre">poll()</span></code> with a single socket, waiting for the <code class="docutils literal notranslate"><span class="pre">POLLIN</span></code> event is
called before actually calling <code class="docutils literal notranslate"><span class="pre">read()</span></code>. To call <code class="docutils literal notranslate"><span class="pre">poll()</span></code>, the configured
receive timeout, stored as <code class="docutils literal notranslate"><span class="pre">avs_time_duration_t</span></code>, needs to be converted to the
unit expected by <code class="docutils literal notranslate"><span class="pre">poll()</span></code> - this is done using
<code class="docutils literal notranslate"><span class="pre">avs_time_duration_to_scalar()</span></code>, with additional adjustments to ensure
expected behavior.</p>
<p>If a timeout occurs, <code class="docutils literal notranslate"><span class="pre">avs_errno(AVS_ETIMEDOUT)</span></code> is returned; if either some
data is available or an error occurs, <code class="docutils literal notranslate"><span class="pre">read()</span></code> is called - in case of error
it will return a negative value, which in this implementation is handled by
returning <code class="docutils literal notranslate"><span class="pre">avs_errno(AVS_EIO)</span></code>, but could be more completely handled by
actually translating the <code class="docutils literal notranslate"><span class="pre">errno</span></code> value.</p>
<p>If some data has been successfully received, <code class="docutils literal notranslate"><span class="pre">*out_bytes_received</span></code> shall be
filled with the number of bytes received.</p>
<p>For datagram sockets, it is additionally important to handle the truncated
message case - so that e.g. the CoAP layer can determine whether the received
payload is complete. Unfortunately, it is non-trivial to do so when using the
<code class="docutils literal notranslate"><span class="pre">read()</span></code> function - that’s why in this simplistic implementation we
pessimistically assume that if the buffer is fully filled, then the data might
have been truncated. Proper handling of this case can be achieved by using the
<code class="docutils literal notranslate"><span class="pre">MSG_TRUNC</span></code> flag, which has not been used because it’s Linux-specific, or by
using the <code class="docutils literal notranslate"><span class="pre">recvmsg()</span></code> API, which has not been done here because the more
convoluted API of that function would make this example code more difficult to
follow.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">*out_bytes_received</span></code> shall be set for both success and
<code class="docutils literal notranslate"><span class="pre">avs_errno(AVS_EMSGSIZE)</span></code> cases.</p>
</div>
</section>
<section id="close">
<h3><a class="toc-backref" href="#id9"><span class="section-number">8.3.1.1.5.4. </span>Close</a><a class="headerlink" href="#close" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">net_close</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="n">avs_error_t</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_EIO</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is pretty self-explanatory - but please note that unlike the POSIX
<code class="docutils literal notranslate"><span class="pre">close()</span></code> function, the close operation on <code class="docutils literal notranslate"><span class="pre">avs_commons</span></code> sockets does
<strong>not</strong> remove the socket object. This is why the cleanup operation exists.</p>
</section>
<section id="cleanup">
<h3><a class="toc-backref" href="#id10"><span class="section-number">8.3.1.1.5.5. </span>Cleanup</a><a class="headerlink" href="#cleanup" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">net_cleanup</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">**</span><span class="n">sock_ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">avs_error_t</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock_ptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">sock_ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">net_close</span><span class="p">(</span><span class="o">*</span><span class="n">sock_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="n">avs_free</span><span class="p">(</span><span class="o">*</span><span class="n">sock_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="o">*</span><span class="n">sock_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The cleanup operation is also self-explanatory, although please note that there
is no requirement to call the close operation before it - that’s why it is
called from inside this function here.</p>
</section>
<section id="get-system-socket">
<h3><a class="toc-backref" href="#id11"><span class="section-number">8.3.1.1.5.6. </span>Get system socket</a><a class="headerlink" href="#get-system-socket" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">net_system_socket</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function is only called by Anjay from <code class="docutils literal notranslate"><span class="pre">anjay_event_loop_run()</span></code> and
<code class="docutils literal notranslate"><span class="pre">anjay_serve_any()</span></code> - but these functions will generally not be available when
Anjay is configured to use custom socket implementation. However, the “system
socket” operation is necessary to implement the
<a class="reference internal" href="../../AdvancedTopics/AT-CustomEventLoop.html"><span class="doc">Custom event loop</span></a> as well.</p>
<p>On platforms that use POSIX-style file descriptor numbers, the standard practice
is to return a pointer to such file descriptor variable. However, the only
actual requirement is that the usage matches the implementation - so you can
return a pointer to any kind of object that you will be able to use to poll for
incoming events in the event loop.</p>
</section>
<section id="get-set-socket-options">
<h3><a class="toc-backref" href="#id12"><span class="section-number">8.3.1.1.5.7. </span>Get/set socket options</a><a class="headerlink" href="#get-set-socket-options" title="Permalink to this headline"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">net_get_opt</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">,</span>
<span class="w">                               </span><span class="n">avs_net_socket_opt_key_t</span><span class="w"> </span><span class="n">option_key</span><span class="p">,</span>
<span class="w">                               </span><span class="n">avs_net_socket_opt_value_t</span><span class="w"> </span><span class="o">*</span><span class="n">out_option_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">option_key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AVS_NET_SOCKET_OPT_RECV_TIMEOUT</span><span class="p">:</span>
<span class="w">        </span><span class="n">out_option_value</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AVS_NET_SOCKET_OPT_STATE</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">out_option_value</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AVS_NET_SOCKET_STATE_CLOSED</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">out_option_value</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AVS_NET_SOCKET_STATE_CONNECTED</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AVS_NET_SOCKET_OPT_INNER_MTU</span><span class="p">:</span>
<span class="w">        </span><span class="n">out_option_value</span><span class="o">-&gt;</span><span class="n">mtu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1464</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AVS_NET_SOCKET_HAS_BUFFERED_DATA</span><span class="p">:</span>
<span class="w">        </span><span class="n">out_option_value</span><span class="o">-&gt;</span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_ENOTSUP</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">avs_error_t</span><span class="w"> </span><span class="nf">net_set_opt</span><span class="p">(</span><span class="n">avs_net_socket_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock_</span><span class="p">,</span>
<span class="w">                               </span><span class="n">avs_net_socket_opt_key_t</span><span class="w"> </span><span class="n">option_key</span><span class="p">,</span>
<span class="w">                               </span><span class="n">avs_net_socket_opt_value_t</span><span class="w"> </span><span class="n">option_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="n">sock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">net_socket_impl_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">sock_</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">option_key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">AVS_NET_SOCKET_OPT_RECV_TIMEOUT</span><span class="p">:</span>
<span class="w">        </span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">recv_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">option_value</span><span class="p">.</span><span class="n">recv_timeout</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">AVS_OK</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">avs_errno</span><span class="p">(</span><span class="n">AVS_ENOTSUP</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">get_opt</span></code>/<code class="docutils literal notranslate"><span class="pre">set_opt</span></code> interface is used for querying and setting various
state information about a given socket. The options that can be get or set are
listed in the <a class="reference external" href="https://github.com/AVSystem/avs_commons/blob/master/include_public/avsystem/commons/avs_socket.h#L502">avs_net_socket_opt_key_t</a>
enumeration. Option values are passed or returned using the
<a class="reference external" href="https://github.com/AVSystem/avs_commons/blob/master/include_public/avsystem/commons/avs_socket.h#L674">avs_net_socket_opt_value_t</a>
union. See the nearby documentation if you need clarification on which field is
used to pass values for which option.</p>
<p>Three of there options are essential for the operation of Anjay:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AVS_NET_SOCKET_OPT_RECV_TIMEOUT</span></code> - used for getting and setting the current
receive timeout, as used by the <a class="reference internal" href="#non-posix-networking-api-receive"><span class="std std-ref">Receive</span></a>
operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AVS_NET_SOCKET_OPT_STATE</span></code> (get-only) - used to check in which state
(closed, shut down, bound, accepted or connected) the socket currently is.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AVS_NET_SOCKET_OPT_INNER_MTU</span></code> (get-only; only used for UDP) - used to check
the number of bytes that can be safely sent and received in a single UDP
datagram over the given socket.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AVS_NET_SOCKET_HAS_BUFFERED_DATA</span></code> (get-only; optional but highly
recommended) - used to check whether all data received from the underlying
system socket has been processed. This is used to make sure that when control
is returned to the event loop, the <code class="docutils literal notranslate"><span class="pre">poll()</span></code> call will not stall waiting for
new data that in reality has been already buffered and could be retrieved
using the avs_commons APIs. This is usually meaningful for (D)TLS connections,
but for almost all simple unencrypted socket implementations, this should
always return <code class="docutils literal notranslate"><span class="pre">false</span></code>. If this option is not supported, then the library
will always retry receiving data until a timeout condition occurs (timeout is
set to zero for subsequent retries), which may lead to stalling of the event
loop.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AVS_NET_SOCKET_OPT_INNER_MTU</span></code> option will be used in addition to
buffer sizes to e.g. calculate the maximum size of packets for Block-wise
CoAP transfers. This is why it is essential to provide this value. If
querying this information from the actual connection or network interface is
not possible, a hardcoded estimate like the one above should be OK.</p>
</div>
</section>
</section>
<section id="limitations">
<h2><a class="toc-backref" href="#id13"><span class="section-number">8.3.1.1.6. </span>Limitations</a><a class="headerlink" href="#limitations" title="Permalink to this headline"></a></h2>
<p>This minimal implementation is enough to make Anjay run, but a number of
functionalities will not work:</p>
<ul class="simple">
<li><p>Attempt to set <a class="reference external" href="../../api/structanjay__configuration.html#acf74549a99ca3ad5aedb227c4b0258ca">anjay_configuration_t::udp_listen_port</a>
will result in no connectivity, as the bind operation is not supported.</p></li>
<li><p>Local port will not be preserved between subsequent connections to the same
server.</p></li>
<li><p>CoAP message cache will not work, regardless of value of the
<a class="reference external" href="../../api/structanjay__configuration.html#a3bb16de58b283370b1ab20698dd4849a">anjay_configuration_t::msg_cache_size</a>
setting.</p></li>
<li><p>Suspending CoAP downloads when entering offline mode will not work; downloads
will be aborted instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">anjay_get_tx_bytes()</span></code> and <code class="docutils literal notranslate"><span class="pre">anjay_get_rx_bytes()</span></code> APIs will not work.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">WITHOUT_IP_STICKINESS</span></code> compile-time flag cannot be disabled, which means
that when connecting to a server using a domain name, it is not guaranteed
that subsequent connections will use the same IP address.</p></li>
</ul>
<p>We will discuss implementing additional methods to address these limitations in
subsequent chapters.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../NetworkingAPI.html" class="btn btn-neutral float-left" title="8.3. Networking API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="NetworkingAPI-RemoteHostPort.html" class="btn btn-neutral float-right" title="8.3.1.2. Get remote host/port operations" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2023, AVSystem.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>